import pandas as pd
from fuzzywuzzy import fuzz


def find_match_by_biz_name(bname, search_DF, threshhold=90, topN=False):
    """Lookup matching records using fuzzy business name comparison

    Searches the search_DF data by copmany name, using fuzz.ratio() of the fuzzywuzzy library

    Args:
        bname (str): Company name to search for
        search_DF (pd.DataFrame): A DF to search with a 'aa_company' column
        threshhold (int): fuzz.ratio of company name and potential matches must be > this number
        topN (boolean): if True, returns a tuple: (matches, topN) where topN is a DF containing
            the top N matches regardless of threshhold value

    Returns:
        If topN=False (default):
            matches (pd.DataFrame): A DF with all the matching records in search_DF above the
                threshhold
        If topN=True: A tuple of (matches, topN)
            matches (pd.DataFrame): A DF with all the matching records in search_DF above the
                threshhold
            topN (pd.DataFrame): A DF with the top N related records to bname from search_DF
                regardless of threshhold value
    """

    bname = str(bname)
    if bname.startswith('nan'):
        if topN:
            return pd.DataFrame(), pd.DataFrame()
        else:
            return pd.DataFrame()

    bname = bname.strip()

    def _compare_names(m_name):
        if m_name.strip() == '':
            return 0
        return fuzz.ratio(bname, m_name)

    temp_MR = search_DF['aa_company'].fillna('').apply(_compare_names)

    matches = search_DF[temp_MR > threshhold]

    if topN:
        # FIXME - this sort doesn't work because I'm no longer storing the scores
        # in a dataframe column (to elimiate a setting with copy warning)
        # why isn't that warning thrown during the find_by_contact() below?
        top_ = search_DF.sort_values(by=['temp_MR'], ascending=False).head(topN)
        return matches, top_
    else:
        return matches


def find_match_by_contact_name(cname, search_DF, threshhold=90, topN=False, nameparts='full'):
    """Lookup matching records using fuzzy contact name

    Searches the search_DF data by full name or last, using fuzz.ratio() of the fuzzywuzzy library

    Args:
        cname (str): Contact name to search for
        search_DF (pd.DataFrame): A DF to search with 'aa_fullname' and/or 'aa_lastname' columns
        threshhold (int): fuzz.ratio of contact name and potential matches must be > this number
        topN (boolean): if True, returns a tuple: (matches, topN) where topN is a DF containing
            the top N matches regardless of threshhold value

    Returns:
        If topN=False (default):
            matches (pd.DataFrame): A DF with all the matching records in search_DF above the
                threshhold
        If topN=True: A tuple of (matches, topN)
            matches (pd.DataFrame): A DF with all the matching records in search_DF above the
                threshhold
            topN (pd.DataFrame): A DF with the top N related records to cname from search_DF
                regardless of threshhold value
    """

    cname = str(cname)
    if cname.startswith('nan'):
        if topN:
            return pd.DataFrame(), pd.DataFrame()
        else:
            return pd.DataFrame()

    cname = cname.strip()

    def _compare_names(m_name):
        if m_name.strip() == '':
            return 0
        return fuzz.ratio(cname, m_name)

    if nameparts == 'full':
        search_DF['temp_MR'] = search_DF['aa_fullname'].fillna('').apply(_compare_names)
    elif nameparts == 'last':
        search_DF['temp_MR'] = search_DF['aa_lastname'].fillna('').apply(_compare_names)

    matches = search_DF[search_DF['temp_MR'] > threshhold]

    if topN:
        top_ = search_DF.sort(columns=['temp_MR'], ascending=False).head(topN)
        return matches, top_
    else:
        return matches


def find_related(search_for, search_in):
    """Searches a DataFrame for the contacts/accounts of another

    Perform a series of searches for each record in search_for against all the records of search_in
    using the columns generated by running each DataFrame through clean.build_matching_cols()

    Args:
        search_for (pd.DataFrame): DF of records to look for
        search_in (pd.DataFrame):  DF of records to look matches in

    Returns:
        A list of tuples like:
            [('match type', search_for.index, [search_in.index]), ... ]
        Where the match type is a description of how the search_for record was matched to the
        following search_in.indices. This format is meant to be used as input for
        match.merge_lists()
    """

    more_than_one = 0
    total_matches = 0
    search_for_related  = []

    num_to_match = len(search_for)

    if not search_for.index.is_unique:
        raise ValueError('Duplicate index entries of records being searched for are not allowed.')
    if not search_in.index.is_unique:
        raise ValueError('Duplicate index entries of records being searched are not allowed.')

    for sf_ind, attendee in search_for.iterrows():

        # Exact match on Full Contact Name and State Abbrv.
        if pd.isnull(attendee.aa_fullname) is False:

            matches = search_in[search_in['aa_fullname'] == attendee.aa_fullname]
            if len(matches) > 0:
                matches = matches[matches.aa_state == attendee.aa_state]

            if len(matches) > 0:
                total_matches += 1

                if len(matches) > 1:
                    more_than_one += 1

                search_for_related.append(('ExactNameState', sf_ind, matches.index))
                continue

        # Exact match on some parts of the address
        matches = search_in[(search_in.aa_streetnum == attendee.aa_streetnum) &
                            (search_in.aa_street    == attendee.aa_street) &
                            (search_in.aa_state     == attendee.aa_state)]

        if len(matches) > 0:
            total_matches += 1

            if len(matches) > 1:
                more_than_one += 1

            search_for_related.append(('ExactAddress', sf_ind, matches.index))
            continue

        # Fuzzy match on Contact Name and Exact match on State
        matches = find_match_by_contact_name(attendee['aa_fullname'], search_in, 89)
        if len(matches) > 0:
            matches = matches[matches.aa_state == attendee.aa_state]

        if len(matches) > 0:
            total_matches += 1

            if len(matches) > 1:
                more_than_one += 1

            search_for_related.append(('fuzzContact-ExactState', sf_ind, matches.index))
            continue

        # Exact match on State and Fuzzy match on business name
        # FIXME! this is not specific enough for National chains
        matches = search_in[search_in.aa_state == attendee.aa_state]
        if len(matches) > 0:
            # No business name column here, so use the contact name again
            matches = find_match_by_biz_name(attendee['aa_company'], matches, 90)

        if len(matches) > 0:
            total_matches += 1

            if len(matches) > 1:
                more_than_one += 1

            search_for_related.append(('FuzzBiz-ExactState', sf_ind, matches.index))
            continue

        # give up no matches for this record
        search_for_related.append((None, None, ()))

    print(''.join((str(round(total_matches / len(search_for.head(num_to_match)) * 100, 2)),
          '% (', str(total_matches), ') of search_for records have at least 1 matching record.')))

    print(''.join((str(round(more_than_one / len(search_for.head(num_to_match)) * 100, 2)),
          '% (', str(more_than_one), ') of search_for records have multiple matching records.')))

    return search_for_related


def merge_lists(dest, src, matching_indices, wanted_cols):
    """Merges contact info from src DataFrame to dest

    Merges two pandas Dataframes using the output of `match.find_related(dest, src)` which is a
    list of matching indices and desired columns tuples. This function is meant to be used on two
    dataframes of contacts/accounts with addresses, names and email addresses partially present in
    either DataFrame.

    Args:
        dest (pd.DataFrame): DF you would like to add columns from another source to
        src (pd.DataFrame): DF containing matching contacts complete with the desired columns
        matching_indices (list): list of tuples - the output of match.find_related():
            [('ExactAddress', 2, Int64Index([2585, 2586]))]
        wanted_cols (list): list of column names (str) to add to the destination dataframe from
            the src dataframe

    Returns:
        output (pd.DataFrame): The dest DF merged with the src[wanted_cols] DF along with a few
            extra columns that are added to document how each record was matched and the original
            index values of each input df that facilitate the join.
    """

    addtl_dest_cols = []
    src_matches = 0

    for (rec_type, dest_ind, src_index) in matching_indices:

        if len(src_index) < 1:
            addtl_dest_cols.append({})
            continue
        elif len(src_index) == 1:
            multi = False
        else:
            multi = True

        src_matches += 1

        matches = src.ix[src_index]

        for id_, m in matches.iterrows():

            # user-requested columns from src data
            total_record = m[wanted_cols].to_dict()

            total_record['src_ID']          = src_index
            total_record['dest_ID']         = dest_ind
            total_record['source_type']     = rec_type
            total_record['multiple_emails'] = multi

            addtl_dest_cols.append(total_record)

    morecols = pd.DataFrame(addtl_dest_cols)

    # How many of the original list we're merging with src did we match by each method?
    print(morecols.drop_duplicates(subset=['dest_ID']).source_type.value_counts())

    output = dest.merge(pd.DataFrame(addtl_dest_cols),
                        suffixes=('_dest', '_src'),
                        right_on='dest_ID',
                        left_index=True,
                        how='left',
                        )
    return output
